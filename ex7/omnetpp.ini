

###################################################################

[General]
network = CurrentNetwork
sim-time-limit = ${simtime=10, 100, 1000}s
repeat = 10

**.networkConfiguratorModule = ""
**.ppp[*].numInputHooks = 1
**.ppp[*].inputHook[0].typename = "ThruputMeter"
**.ppp[*].inputHook[0].maxInterval = 0.1s
**.ppp[*].inputHook[0].batchSize = 10000
**.ppp[*].inputHook[0].**.vector-recording = true
**.vector-recording = true
**.scalar-recording = true
# NIC configuration

# Each router is output port buffered and the buffer
# has a maximum capacity of 40 IP packets, regardless of their size:

# Define a simple DropTailQueue
**.ppp[*].queueType = "DropTailQueue"
# The queue is supposed to buffer 40 packets/frames
**.ppp[*].queue.frameCapacity = 40


[Config CurrentNetwork]
sim-time-limit = 100s

# user settings
# The TCPBasicClientApp opens a connection and sends a specified number of requests
# The requests contain the length of the response (replyLength)
# The thinktime specifies the time between those requests.
# When the number of requests of a session is sent, the session closes
# After the time specified in idleInterval a new session is opened.
**.user[*].numTcpApps = 1
**.user[*].tcpApp[0].typename = "TCPBasicClientApp"
**.user[*].tcpApp[0].localPort = -1
**.user[*].tcpApp[0].numRequestsPerSession = 1
**.user[*].tcpApp[0].connectAddress = "internet"
**.user[*].tcpApp[0].connectPort = 1000
# Maybe use ?8KiB? for requestLength according to maximum http 1.0 get request size
**.user[*].tcpApp[0].requestLength = 200B
**.user[*].tcpApp[0].thinkTime = 0

# Measurements have shown that the file size is exponentially
# distributed with a mean value of 150 kB
**.user[*].tcpApp[0].replyLength = exponential(150KiB)
# The pause time is also exponentially distributed with a mean of 30 s.
**.user[*].tcpApp[0].idleInterval = exponential(30s)

   
# internet settings
# The TCPGenericSrvApp replys to a requests, which specifies the replylength.
# An unlimited number of sessions can be opened.
**.internet.numTcpApps = 1
**.internet.tcpApp[0].typename = "TCPGenericSrvApp"
**.internet.tcpApp[0].localPort = 1000
**.internet.tcpApp[0].echoFactor = 0

# This is important for the TCPGenericSrvApp to reply to the requests
**.tcpApp[*].dataTransferMode = "object"
# The routers currently support only IP packets containing
# TCP segments with a Maximum Segment Size (MSS) of 1000 Byte.
**.tcp.mss = 1000

# TCPNewReno
**.tcpType = "TCP"
**.tcp.tcpAlgorithmClass = "TCPNewReno"
# The upper bound of the congestion window is supposed to be 100
# Alex: I'm not quite sure if this does the trick.
**.tcp.advertisedWindow = 100


[Config VoiceTest]
sim-time-limit = 100s

**.vector-recording = true

# user settings
# The TCPBasicClientApp opens a connection and sends a specified number of requests
# The requests contain the length of the response (replyLength)
# The thinktime specifies the time between those requests.
# When the number of requests of a session is sent, the session closes
# After the time specified in idleInterval a new session is opened.

# General Setup for voice
**.user[*].numUdpApps = 2
**.user[*].udpApp[0].typename = "VoIPApp"
**.user[*].udpApp[0].localPort = -1
**.user[*].udpApp[0].destPort = 1000
**.user[*].udpApp[0].sendInterval = 20ms
**.user[*].udpApp[0].messageLength = 32B
**.user[*].udpApp[0].startTime = 1s
**.user[*].udpApp[0].maxDelay = 200ms

**.user[*].udpApp[1].typename = "VoIPApp"
**.user[*].udpApp[1].localPort = 1000
**.user[*].udpApp[1].destPort = -1
**.user[*].udpApp[1].destAddresses = ""
**.user[*].udpApp[1].sendInterval = 0s
**.user[*].udpApp[1].messageLength = 0B
**.user[*].udpApp[1].startTime = 0.5s
**.user[*].udpApp[1].maxDelay = 200ms

#Individual connections of udp apps

# NOTE: First generate worst case user interconnections manually by shell:
# ./user_connector.py -voip -b <backbones> -a <access_routers_per_bb> -u <users_per_access_router>
#    e.g.: ./user_connector.py -voip -b 2 -a 1 -u 2
include user_connections_voicetest.ini




[Config Simultaneous]

# user settings
# The TCPBasicClientApp opens a connection and sends a specified number of requests
# The requests contain the length of the response (replyLength)
# The thinktime specifies the time between those requests.
# When the number of requests of a session is sent, the session closes
# After the time specified in idleInterval a new session is opened.
**.user[*].numTcpApps = 1
**.user[*].tcpApp[0].typename = "TCPBasicClientApp"
**.user[*].tcpApp[0].localPort = -1
**.user[*].tcpApp[0].numRequestsPerSession = 1
**.user[*].tcpApp[0].connectAddress = "internet"
**.user[*].tcpApp[0].connectPort = 80
**.user[*].tcpApp[0].requestLength = 8KiB
**.user[*].tcpApp[0].thinkTime = 0

# Measurements have shown that the file size is exponentially
# distributed with a mean value of 150 kB
**.user[*].tcpApp[0].replyLength = exponential(150KiB)
# The pause time is also exponentially distributed with a mean of 30 s.
**.user[*].tcpApp[0].idleInterval = exponential(30s)

   
# internet settings
# The TCPGenericSrvApp replys to a requests, which specifies the replylength.
# An unlimited number of sessions can be opened.
**.internet.numTcpApps = 1
**.internet.tcpApp[0].typename = "TCPGenericSrvApp"
**.internet.tcpApp[0].localPort = 80
**.internet.tcpApp[0].echoFactor = 0

# This is important for the TCPGenericSrvApp to reply to the requests
**.tcpApp[*].dataTransferMode = "object"
# The routers currently support only IP packets containing
# TCP segments with a Maximum Segment Size (MSS) of 1000 Byte.
**.tcp.mss = 1000

# TCPNewReno
**.tcpType = "TCP"
**.tcp.tcpAlgorithmClass = "TCPNewReno"
# The upper bound of the congestion window is supposed to be 100
# Alex: I'm not quite sure if this does the trick.
**.tcp.advertisedWindow = 100


#CurrentNetwork.num_bb 
*.num_bb = 2
*.num_access_per_bb = 2
*.num_user_per_access = 2
# REMEMBER TO MANUALLY EXECUTE THE CONNECTOR SCRIPT

# user settings
**.user[*].numUdpApps = 1
**.user[*].udpApp[0].typename = "VoIPApp"
**.user[*].udpApp[0].localPort = 1000
**.user[*].udpApp[0].destPort = 1000
**.user[*].udpApp[0].sendInterval = 200ms
**.user[*].udpApp[0].messageLength = 1000B
**.user[*].udpApp[0].startTime = 1s
**.user[*].udpApp[0].maxDelay = 200ms
#**.user[x].udpApp[0].destAddresses = "user[1]"

# Generate worst case user interconnections manually by shell:
# ./user_connector.py -b <backbones> -a <access_routers_per_bb> -u <users_per_access_router>
#    e.g.: ./user_connector.py -b 2 -a 1 -u 2
include user_connections.ini


